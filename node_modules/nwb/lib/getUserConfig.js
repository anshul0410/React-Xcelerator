'use strict';

exports.__esModule = true;
exports.UserConfigReport = undefined;
exports.prepareWebpackLoaderConfig = prepareWebpackLoaderConfig;
exports.processUserConfig = processUserConfig;
exports.default = getUserConfig;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _figures = require('figures');

var _figures2 = _interopRequireDefault(_figures);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _constants = require('./constants');

var _createWebpackConfig = require('./createWebpackConfig');

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _errors = require('./errors');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_REQUIRED = false;

var BABEL_RUNTIME_OPTIONS = ['helpers', 'polyfill'];

var s = function s(n) {
  return n === 1 ? '' : 's';
};

var UserConfigReport = exports.UserConfigReport = function () {
  function UserConfigReport(configPath) {
    _classCallCheck(this, UserConfigReport);

    this.configPath = configPath;
    this.deprecations = [];
    this.errors = [];
    this.hints = [];
  }

  UserConfigReport.prototype.deprecated = function deprecated(path) {
    for (var _len = arguments.length, messages = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      messages[_key - 1] = arguments[_key];
    }

    this.deprecations.push({ path: path, messages: messages });
  };

  UserConfigReport.prototype.error = function error(path, value, message) {
    this.errors.push({ path: path, value: value, message: message });
  };

  UserConfigReport.prototype.hasErrors = function hasErrors() {
    return this.errors.length > 0;
  };

  UserConfigReport.prototype.hasSomethingToReport = function hasSomethingToReport() {
    return this.errors.length + this.deprecations.length + this.hints.length > 0;
  };

  UserConfigReport.prototype.hint = function hint(path) {
    for (var _len2 = arguments.length, messages = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      messages[_key2 - 1] = arguments[_key2];
    }

    this.hints.push({ path: path, messages: messages });
  };

  UserConfigReport.prototype.log = function log() {
    console.log(_chalk2.default.underline('nwb config report for ' + this.configPath));
    console.log();
    if (!this.hasSomethingToReport()) {
      console.log(_chalk2.default.green(_figures2.default.tick + ' Nothing to report!'));
      return;
    }

    if (this.errors.length) {
      var count = this.errors.length > 1 ? this.errors.length + ' ' : '';
      console.log(_chalk2.default.red.underline(count + 'Error' + s(this.errors.length)));
      console.log();
    }
    this.errors.forEach(function (_ref) {
      var path = _ref.path;
      var value = _ref.value;
      var message = _ref.message;

      console.log(_chalk2.default.red(_figures2.default.cross + ' ' + path) + ' ' + _chalk2.default.cyan('=') + ' ' + _util2.default.inspect(value));
      console.log('  ' + message);
      console.log();
    });
    if (this.deprecations.length) {
      var _count = this.deprecations.length > 1 ? this.deprecations.length + ' ' : '';
      console.log(_chalk2.default.yellow.underline(_count + 'Deprecation Warning' + s(this.deprecations.length)));
      console.log();
    }
    this.deprecations.forEach(function (_ref2) {
      var path = _ref2.path;
      var messages = _ref2.messages;

      console.log(_chalk2.default.yellow(_figures2.default.warning + ' ' + path));
      messages.forEach(function (message) {
        console.log('  ' + message);
      });
      console.log();
    });
    if (this.hints.length) {
      var _count2 = this.hints.length > 1 ? this.hints.length + ' ' : '';
      console.log(_chalk2.default.cyan.underline(_count2 + 'Hint' + s(this.hints.length)));
      console.log();
    }
    this.hints.forEach(function (_ref3) {
      var path = _ref3.path;
      var messages = _ref3.messages;

      console.log(_chalk2.default.cyan(_figures2.default.info + ' ' + path));
      messages.forEach(function (message) {
        console.log('  ' + message);
      });
      console.log();
    });
  };

  return UserConfigReport;
}();

/**
 * Move loader query config tweaks into a query object, allowing users to
 * provide a flat config.
 */


function prepareWebpackLoaderConfig(loaders) {
  Object.keys(loaders).forEach(function (loaderId) {
    var loader = loaders[loaderId];
    if (loader.query) return loader;
    var config = loader.config;
    var exclude = loader.exclude;
    var include = loader.include;
    var test = loader.test;

    var query = _objectWithoutProperties(loader, ['config', 'exclude', 'include', 'test']); // eslint-disable-line no-unused-vars


    if (Object.keys(query).length > 0) {
      loader.query = query;
      Object.keys(query).forEach(function (prop) {
        return delete loader[prop];
      });
    }
  });
}

var warnedAboutBabelLoose = false;
var warnedAboutBuildChange = false;
var warnedAboutKarmaTests = false;

// TODO Remove in a future version
function upgradeBuildConfig(build, userConfigPath) {
  var report = arguments.length <= 2 || arguments[2] === undefined ? {
    deprecated: function deprecated() {}
  } : arguments[2];

  var npm = {};
  if (build.jsNext) {
    npm.esModules = !!build.jsNext;
  }
  if (build.umd) {
    var hasExternals = !!build.externals && Object.keys(build.externals).length > 0;
    if (!hasExternals) {
      npm.umd = build.global;
    } else {
      npm.umd = { global: build.global, externals: build.externals };
    }
  }
  if (!warnedAboutBuildChange) {
    var messages = ['Deprecated in favour of ' + _chalk2.default.green('npm') + ' config as of nwb v0.12.', 'nwb will upgrade ' + _chalk2.default.yellow('build') + ' config to ' + _chalk2.default.green('npm') + ' format during a build.', 'Equivalent ' + _chalk2.default.green('npm') + ' config to your current ' + _chalk2.default.yellow('build') + ' config is:', ''].concat(JSON.stringify({ npm: npm }, null, 2).split('\n').map(function (line) {
      return '  ' + _chalk2.default.cyan(line);
    }));
    if (npm.esModules) {
      messages.push('', 'You have the ES6 modules build enabled, so also add ' + _chalk2.default.cyan('"module": "es/index.js"') + ' to ' + _chalk2.default.cyan('package.json') + '.', 'This is part of a proposal for future native module support being supported by multiple bundlers.', '(You should also change ' + _chalk2.default.cyan('"jsnext:main"') + ' to point at ' + _chalk2.default.cyan('"es/index.js"') + ')');
    }
    report.deprecated.apply(report, ['build'].concat(messages));
    warnedAboutBuildChange = true;
  }
  return npm;
}

/**
 * Validate user config and perform any necessary validation and transformation
 * to it.
 */
function processUserConfig(_ref4) {
  var args = _ref4.args;
  var _ref4$check = _ref4.check;
  var check = _ref4$check === undefined ? false : _ref4$check;
  var _ref4$required = _ref4.required;
  var required = _ref4$required === undefined ? DEFAULT_REQUIRED : _ref4$required;
  var userConfig = _ref4.userConfig;
  var userConfigPath = _ref4.userConfigPath;

  // Config modules can export a function if they need to access the current
  // command or the webpack dependency nwb manages for them.
  if ((0, _utils.typeOf)(userConfig) === 'function') {
    userConfig = userConfig({
      command: args._[0],
      webpack: _webpack2.default
    });
  }

  var report = new UserConfigReport(userConfigPath);

  if ((required || 'type' in userConfig) && _constants.PROJECT_TYPES.indexOf(userConfig.type) === -1) {
    report.error('type', userConfig.type, 'Must be one of: ' + _constants.PROJECT_TYPES.join(', '));
  }

  // TODO Remove in a future version
  if (userConfig.build) {
    userConfig.npm = upgradeBuildConfig(userConfig.build, userConfigPath, report);
    delete userConfig.build;
  }

  // Set defaults for config objects so we don't have to existence-check them
  // everywhere.
  void ['babel', 'karma', 'npm', 'webpack'].forEach(function (prop) {
    if (!(prop in userConfig)) userConfig[prop] = {};
  });

  // Babel config
  if (!!userConfig.babel.stage || userConfig.babel.stage === 0) {
    if ((0, _utils.typeOf)(userConfig.babel.stage) !== 'number') {
      report.error('babel.stage', userConfig.babel.stage, 'Must be a ' + _chalk2.default.cyan('Number') + ' between ' + _chalk2.default.cyan('0') + ' and ' + _chalk2.default.cyan('3') + ', ' + ('or ' + _chalk2.default.cyan('false') + ' to disable use of a stage preset.'));
    } else if (userConfig.babel.stage < 0 || userConfig.babel.stage > 3) {
      report.error('babel.stage', userConfig.babel.stage, 'Must be between ' + _chalk2.default.cyan(0) + ' and ' + _chalk2.default.cyan(3));
    }
  }
  if (userConfig.babel.presets && !Array.isArray(userConfig.babel.presets)) {
    report.error('babel.presets', userConfig.babel.presets, 'Must be an ' + _chalk2.default.cyan('Array'));
  }
  if (userConfig.babel.plugins && !Array.isArray(userConfig.babel.plugins)) {
    report.error('babel.plugins', userConfig.babel.plugins, 'Must be an ' + _chalk2.default.cyan('Array'));
  }
  if ('runtime' in userConfig.babel && (0, _utils.typeOf)(userConfig.babel.runtime) !== 'boolean' && BABEL_RUNTIME_OPTIONS.indexOf(userConfig.babel.runtime) === -1) {
    report.error('babel.runtime', userConfig.babel.runtime, 'Must be ' + _chalk2.default.cyan('boolean') + ', ' + _chalk2.default.cyan("'helpers'") + ' or ' + _chalk2.default.cyan("'polyfill'") + ')');
  }
  // TODO Remove in a future version
  else if (userConfig.babel.optional) {
      var messages = ['This Babel 5 config is deprecated in favour of ' + _chalk2.default.green('runtime') + ' config as of nwb v0.12.'];
      if ((0, _utils.typeOf)(userConfig.babel.optional) === 'array' && userConfig.babel.optional.length === 1 && userConfig.babel.optional[0] === 'runtime') {
        messages.push('nwb will convert ' + _chalk2.default.yellow("optional = ['runtime']") + ' config to ' + _chalk2.default.cyan('runtime = true') + ' during a build');
        userConfig.babel.runtime = true;
      }
      report.deprecated.apply(report, ['babel.optional'].concat(messages));
    }
  // TODO Remove in a future version - don't convert, just validate
  if ('loose' in userConfig.babel && (0, _utils.typeOf)(userConfig.babel.loose) !== 'boolean') {
    if (!warnedAboutBabelLoose) {
      var _messages = ['Must be ' + _chalk2.default.cyan('boolean') + ' as of nwb v0.12.', 'nwb will convert non-boolean config to its boolean equivalent during a build.'];
      if (userConfig.babel.loose) {
        _messages.push('(Loose mode is enabled by default as of nwb v0.12, so you can remove this config)');
      }
      report.deprecated.apply(report, ['babel.loose'].concat(_messages));
      warnedAboutBabelLoose = true;
    }
    userConfig.babel.loose = !!userConfig.babel.loose;
  } else if (userConfig.babel.loose === true) {
    report.hint('babel.loose', 'Loose mode is enabled by default as of nwb v0.12, so you can remove this config.');
  }

  // Karma config
  // TODO Remove in a future version
  if (userConfig.karma.tests) {
    var _messages2 = ['Deprecated as of nwb v0.12.'];
    if (userConfig.karma.tests.indexOf('*') !== -1) {
      _messages2.push(_chalk2.default.yellow('karma.tests') + ' appears to be a ' + _chalk2.default.cyan('file glob') + ' so you should rename it to ' + _chalk2.default.green('karma.testFiles'), 'nwb will use it as ' + _chalk2.default.green('karma.testFiles') + ' config during a build.');
      userConfig.karma.testFiles = userConfig.karma.tests;
    } else if (_glob2.default.sync(userConfig.karma.tests, { nodir: true }).length === 1 && _fs2.default.readFileSync(userConfig.karma.tests, 'utf8').indexOf('require.context') !== -1) {
      _messages2.push(_chalk2.default.yellow('karma.tests') + ' appears to be a ' + _chalk2.default.cyan('Webpack context module') + ', so you should rename it to ' + _chalk2.default.green('karma.testContext'), 'nwb will use it as ' + _chalk2.default.green('karma.testContext') + ' config during a build.');
      userConfig.karma.testContext = userConfig.karma.tests;
    } else {
      _messages2.push('If ' + _chalk2.default.yellow('karma.tests') + ' points at a ' + _chalk2.default.cyan('Webpack context module') + ', use ' + _chalk2.default.green('karma.testContext') + ' instead.', 'If ' + _chalk2.default.yellow('karma.tests') + ' is a ' + _chalk2.default.cyan('file glob') + ', use ' + _chalk2.default.green('karma.testFiles') + ' instead.', 'nwb can\'t tell, so will fall back to default config during a build.');
    }
    if (!warnedAboutKarmaTests) {
      report.deprecated.apply(report, ['karma.tests'].concat(_messages2));
      warnedAboutKarmaTests = true;
    }
    delete userConfig.karma.tests;
  }

  // npm build config
  if ((0, _utils.typeOf)(userConfig.npm.umd) === 'string') {
    userConfig.npm.umd = { global: userConfig.npm.umd };
  }

  // Webpack config
  if ((0, _utils.typeOf)(userConfig.webpack.autoprefixer) === 'string') {
    userConfig.webpack.autoprefixer = { browsers: userConfig.webpack.autoprefixer };
  }

  if ('copy' in userConfig.webpack) {
    if ((0, _utils.typeOf)(userConfig.webpack.copy) === 'array') {
      userConfig.webpack.copy = { patterns: userConfig.webpack.copy };
    } else if ((0, _utils.typeOf)(userConfig.webpack.copy) === 'object') {
      if (!userConfig.webpack.copy.patterns && !userConfig.webpack.copy.options) {
        report.error('webpack.copy', userConfig.webpack.copy, 'Must include ' + _chalk2.default.cyan('patterns') + ' or ' + _chalk2.default.cyan('options') + ' when given as an ' + _chalk2.default.cyan('Object'));
      }
      if (userConfig.webpack.copy.patterns && (0, _utils.typeOf)(userConfig.webpack.copy.patterns) !== 'array') {
        report.error('webpack.copy.patterns', userConfig.webpack.copy.patterns, 'Must be an ' + _chalk2.default.cyan('Array') + ' when provided');
      }
      if (userConfig.webpack.copy.options && (0, _utils.typeOf)(userConfig.webpack.copy.options) !== 'object') {
        report.error('webpack.copy.options', userConfig.webpack.copy.options, 'Must be an ' + _chalk2.default.cyan('Object') + ' when provided.');
      }
    } else {
      report.error('webpack.copy', userConfig.webpack.copy, 'Must be an ' + _chalk2.default.cyan('Array') + ' or an ' + _chalk2.default.cyan('Object') + '.');
    }
  }

  if (userConfig.webpack.compat) {
    var compatProps = Object.keys(userConfig.webpack.compat);
    var unknownCompatProps = compatProps.filter(function (prop) {
      return !(prop in _createWebpackConfig.COMPAT_CONFIGS);
    });
    if (unknownCompatProps.length !== 0) {
      report.error('userConfig.webpack.compat', compatProps, 'Unknown propert' + (unknownCompatProps.length === 1 ? 'y' : 'ies') + ' present.' + ('Valid properties are: ' + Object.keys(_createWebpackConfig.COMPAT_CONFIGS).join(', ') + '.'));
    }

    if (userConfig.webpack.compat.moment && (0, _utils.typeOf)(userConfig.webpack.compat.moment.locales) !== 'array') {
      report.error('webpack.compat.moment.locales', _webpack2.default.compat.moment.locales, 'Must be an Array.');
    }
  }

  if (userConfig.webpack.vendorBundle === false) {
    report.error('webpack.vendorBundle', _webpack2.default.vendorBundle, 'No longer supported - add a --no-vendor flag to your build command instead.');
  }

  if (userConfig.webpack.loaders) {
    prepareWebpackLoaderConfig(userConfig.webpack.loaders);
  }

  if ((0, _utils.typeOf)(userConfig.webpack.postcss) === 'array') {
    userConfig.webpack.postcss = { defaults: userConfig.webpack.postcss };
  }

  if (userConfig.webpack.extra) {
    if (userConfig.webpack.extra.output && userConfig.webpack.extra.output.publicPath) {
      report.hint('webpack.extra.output.publicPath', 'You can use the more convenient ' + _chalk2.default.green('webpack.publicPath') + ' instead.');
    }
    if (userConfig.webpack.extra.resolve && userConfig.webpack.extra.resolve.alias) {
      report.hint('webpack.extra.resolve.alias', 'You can use the more convenient ' + _chalk2.default.green('webpack.aliases') + ' instead.');
    }
  }

  if (report.hasErrors()) {
    throw new _errors.ConfigValidationError(report);
  }
  if (check) {
    throw report;
  }
  if (report.hasSomethingToReport()) {
    report.log();
  }

  (0, _debug2.default)('user config: %s', (0, _utils.deepToString)(userConfig));

  return userConfig;
}

/**
 * Load a user config file and process it.
 */
function getUserConfig() {
  var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var _options$check = options.check;
  var check = _options$check === undefined ? false : _options$check;
  var _options$required = options.required;
  var required = _options$required === undefined ? DEFAULT_REQUIRED : _options$required;
  // Try to load default user config, or use a config file path we were given

  var userConfig = {};
  var userConfigPath = _path2.default.resolve(args.config || _constants.CONFIG_FILE_NAME);

  // Bail early if a config file is required and doesn't exist
  var configFileExists = _glob2.default.sync(userConfigPath).length !== 0;
  if ((args.config || required) && !configFileExists) {
    throw new _errors.UserError('Couldn\'t find a config file at ' + userConfigPath);
  }

  // If a config file exists, it should be a valid module regardless of whether
  // or not it's required.
  if (configFileExists) {
    try {
      userConfig = require(userConfigPath);
      (0, _debug2.default)('imported config module from %s', userConfigPath);
      // Delete the file from the require cache as some builds need to import
      // it multiple times with a different NODE_ENV in place.
      delete require.cache[userConfigPath];
    } catch (e) {
      throw new _errors.UserError('Couldn\'t import the config file at ' + userConfigPath + ': ' + e.message + '\n' + e.stack);
    }
  }

  return processUserConfig({ args: args, check: check, required: required, userConfig: userConfig, userConfigPath: userConfigPath });
}