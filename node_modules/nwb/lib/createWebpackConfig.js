'use strict';

exports.__esModule = true;
exports.COMPAT_CONFIGS = exports.styleLoaderName = exports.loaderConfigFactory = exports.combineLoaders = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.mergeLoaderConfig = mergeLoaderConfig;
exports.createStyleLoader = createStyleLoader;
exports.createLoaders = createLoaders;
exports.createExtraLoaders = createExtraLoaders;
exports.createPlugins = createPlugins;
exports.getTopLevelLoaderConfig = getTopLevelLoaderConfig;
exports.createPostCSSConfig = createPostCSSConfig;
exports.getCompatConfig = getCompatConfig;
exports.default = createWebpackConfig;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _autoprefixer = require('autoprefixer');

var _autoprefixer2 = _interopRequireDefault(_autoprefixer);

var _caseSensitivePathsWebpackPlugin = require('case-sensitive-paths-webpack-plugin');

var _caseSensitivePathsWebpackPlugin2 = _interopRequireDefault(_caseSensitivePathsWebpackPlugin);

var _copyWebpackPlugin = require('copy-webpack-plugin');

var _copyWebpackPlugin2 = _interopRequireDefault(_copyWebpackPlugin);

var _extractTextWebpackPlugin = require('extract-text-webpack-plugin');

var _extractTextWebpackPlugin2 = _interopRequireDefault(_extractTextWebpackPlugin);

var _htmlWebpackPlugin = require('html-webpack-plugin');

var _htmlWebpackPlugin2 = _interopRequireDefault(_htmlWebpackPlugin);

var _npmInstallWebpackPlugin = require('npm-install-webpack-plugin');

var _npmInstallWebpackPlugin2 = _interopRequireDefault(_npmInstallWebpackPlugin);

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _webpackFailPlugin = require('webpack-fail-plugin');

var _webpackFailPlugin2 = _interopRequireDefault(_webpackFailPlugin);

var _webpackMd5Hash = require('webpack-md5-hash');

var _webpackMd5Hash2 = _interopRequireDefault(_webpackMd5Hash);

var _webpackMerge = require('webpack-merge');

var _webpackMerge2 = _interopRequireDefault(_webpackMerge);

var _HashedModuleIdsPlugin = require('../vendor/HashedModuleIdsPlugin');

var _HashedModuleIdsPlugin2 = _interopRequireDefault(_HashedModuleIdsPlugin);

var _createBabelConfig = require('./createBabelConfig');

var _createBabelConfig2 = _interopRequireDefault(_createBabelConfig);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _utils = require('./utils');

var _WebpackStatusPlugin = require('./WebpackStatusPlugin');

var _WebpackStatusPlugin2 = _interopRequireDefault(_WebpackStatusPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// Top-level property names reserved for webpack config
// From http://webpack.github.io/docs/configuration.html
var WEBPACK_RESERVED = 'context entry output module resolve resolveLoader externals target bail profile cache watch watchOptions debug devtool devServer node amd loader recordsPath recordsInputPath recordsOutputPath plugins'.split(' ');

/**
 * Create a loader string from a list of {loader, query} objects.
 */
var combineLoaders = exports.combineLoaders = function combineLoaders(loaders) {
  return loaders.map(function (loader) {
    var query = _qs2.default.stringify(loader.query, { arrayFormat: 'brackets' });
    return '' + loader.loader + (query && '?' + query);
  }).join('!');
};

/**
 * Merge webpack loader config ({test, loader, query, include, exclude}) objects.
 */
function mergeLoaderConfig() {
  var defaultConfig = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // Don't include a 'config' object if the user provided one - this will be
  // configured at the top level instead.
  var config = userConfig.config;

  var userLoaderConfig = _objectWithoutProperties(userConfig, ['config']); // eslint-disable-line no-unused-vars


  var loader = (0, _webpackMerge2.default)(defaultConfig, buildConfig, userLoaderConfig);
  if (loader.query && Object.keys(loader.query).length === 0) {
    delete loader.query;
  }
  return loader;
}

/**
 * Create a function which configures a loader identified by a unique id, with
 * the option to override defaults with build-specific and user config.
 */
var loaderConfigFactory = exports.loaderConfigFactory = function loaderConfigFactory(buildConfig, userConfig) {
  return function (id, defaultConfig) {
    if (id) {
      return _extends({ id: id }, mergeLoaderConfig(defaultConfig, buildConfig[id], userConfig[id]));
    }
    return defaultConfig;
  };
};

/**
 * Create a function which applies a prefix to a given name when a prefix is
 * given, unless the prefix ends with a name, in which case the prefix itself is
 * returned.
 * The latter rule is to allow loaders created for CSS preprocessor plugins to
 * be given unique ids for user configuration without duplicating the name of
 * the loader.
 * e.g.: styleLoaderName('sass')('css') => 'sass-css'
 *       styleLoaderName('sass')('sass') => 'sass' (as opposed to 'sass-sass')
 */
var styleLoaderName = exports.styleLoaderName = function styleLoaderName(prefix) {
  return function (name) {
    if (prefix && (0, _utils.endsWith)(prefix, name)) {
      return prefix;
    }
    return prefix ? prefix + '-' + name : name;
  };
};

/**
 * Create a default style-handling pipeline for either a static build (default)
 * or a server build.
 */
function createStyleLoader(loader, server) {
  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref$preprocessor = _ref.preprocessor;
  var preprocessor = _ref$preprocessor === undefined ? null : _ref$preprocessor;
  var _ref$prefix = _ref.prefix;
  var prefix = _ref$prefix === undefined ? null : _ref$prefix;

  var name = styleLoaderName(prefix);
  var loaders = [loader(name('css'), {
    loader: require.resolve('css-loader'),
    query: {
      // Prevent cssnano from using Autoprefixer to remove prefixes
      autoprefixer: false,
      // Apply postcss-loader to @imports
      importLoaders: 1
    }
  }), loader(name('postcss'), {
    loader: require.resolve('postcss-loader'),
    query: {
      pack: prefix
    }
  })];

  if (preprocessor) {
    loaders.push(loader(name(preprocessor.id), preprocessor.config));
  }

  if (server) {
    loaders.unshift(loader(name('style'), {
      loader: require.resolve('style-loader')
    }));
    return combineLoaders(loaders);
  } else {
    return _extractTextWebpackPlugin2.default.extract(require.resolve('style-loader'), combineLoaders(loaders));
  }
}

/**
 * Final webpack loader config consists of:
 * - the default set of loaders created in this function, with build and user
 *   config tweaks based on loader id.
 * - extra loaders defined in build config, with user config tweaks based
 *   on loader id.
 * - extra loaders created for CSS preprocessor plugins, with user config
 *   tweaks based on loader id.
 * - extra loaders defined in user config.
 */
function createLoaders(server) {
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  var pluginConfig = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var loader = loaderConfigFactory(buildConfig, userConfig);

  // Default query options for url-loader
  var urlLoaderOptions = {
    // Don't inline anything by default
    limit: 1,
    // Always use a hash to prevent files with the same name causing issues
    name: '[name].[hash:8].[ext]'
  };

  var loaders = [loader('babel', {
    test: /\.js$/,
    loader: require.resolve('babel-loader'),
    exclude: process.env.NWB_TEST ? /(node_modules|nwb[\\/]polyfills\.js$)/ : /node_modules/,
    query: {
      // Don't look for .babelrc files
      babelrc: false,
      // Cache transformations to the filesystem (in default OS temp dir)
      cacheDirectory: true
    }
  }), loader('css-pipeline', {
    test: /\.css$/,
    loader: createStyleLoader(loader, server),
    exclude: /node_modules/
  }), loader('vendor-css-pipeline', {
    test: /\.css$/,
    loader: createStyleLoader(loader, server, {
      prefix: 'vendor'
    }),
    include: /node_modules/
  }), loader('graphics', {
    test: /\.(gif|png|svg|webp)(\?.*)?$/,
    loader: require.resolve('url-loader'),
    query: _extends({}, urlLoaderOptions)
  }), loader('jpeg', {
    test: /\.jpe?g(\?.*)?$/,
    loader: require.resolve('url-loader'),
    query: _extends({}, urlLoaderOptions)
  }), loader('fonts', {
    test: /\.(eot|otf|ttf|woff|woff2)(\?.*)?$/,
    loader: require.resolve('url-loader'),
    query: _extends({}, urlLoaderOptions)
  }), loader('video', {
    test: /\.(mp4|ogg|webm)(\?.*)?$/,
    loader: require.resolve('url-loader'),
    query: _extends({}, urlLoaderOptions)
  }), loader('audio', {
    test: /\.(wav|mp3|m4a|aac|oga)(\?.*)?$/,
    loader: require.resolve('url-loader'),
    query: _extends({}, urlLoaderOptions)
  }), loader('json', {
    test: /\.json$/,
    loader: require.resolve('json-loader')
  })].concat(createExtraLoaders(buildConfig.extra, userConfig));

  if (pluginConfig.cssPreprocessors) {
    Object.keys(pluginConfig.cssPreprocessors).forEach(function (id) {
      var _pluginConfig$cssPrep = pluginConfig.cssPreprocessors[id];
      var test = _pluginConfig$cssPrep.test;

      var config = _objectWithoutProperties(_pluginConfig$cssPrep, ['test']);

      loaders.push(loader(id + '-pipeline', {
        test: test,
        loader: createStyleLoader(loader, server, {
          prefix: id,
          preprocessor: { id: id, config: config }
        }),
        exclude: /node_modules/
      }));
      loaders.push(loader('vendor-' + id + '-pipeline', {
        test: test,
        loader: createStyleLoader(loader, server, {
          prefix: 'vendor-' + id,
          preprocessor: { id: id, config: config }
        }),
        include: /node_modules/
      }));
    });
  }

  return loaders;
}

/**
 * Create loaders from loader definitions which may include an id attribute for
 * user customisation. It's assumed these are being created from build config.
 */
function createExtraLoaders() {
  var extraLoaders = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var userConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var loader = loaderConfigFactory({}, userConfig);
  return extraLoaders.map(function (extraLoader) {
    var id = extraLoader.id;

    var loaderConfig = _objectWithoutProperties(extraLoader, ['id']);

    return loader(id, loaderConfig);
  });
}

/**
 * Plugin for HtmlPlugin which inlines content for an extracted Webpack
 * manifest into the HTML page in a <script> tag before other emitted asssets
 * are injected by HtmlPlugin itself.
 */
function injectManifestPlugin() {
  this.plugin('compilation', function (compilation) {
    compilation.plugin('html-webpack-plugin-before-html-processing', function (data, cb) {
      Object.keys(compilation.assets).forEach(function (key) {
        if (key.indexOf('manifest.') !== 0) return;
        var children = compilation.assets[key].children;

        if (children && children[0]) {
          data.html = data.html.replace(/^(\s*)<\/body>/m, '$1<script>' + children[0]._value + '</script>\n$1</body>');
          // Remove the manifest from HtmlPlugin's assets to
          // prevent a <script> tag being created for it.
          var manifestIndex = data.assets.js.indexOf(data.assets.publicPath + key);
          data.assets.js.splice(manifestIndex, 1);
          delete data.assets.chunks.manifest;
        }
        // Prevent manifest .js and .js.map files being emitted
        delete compilation.assets[key];
      });
      cb();
    });
  });
}

function getCopyPluginArgs(buildConfig, userConfig) {
  var patterns = [];
  var options = {};
  if (buildConfig) {
    patterns = patterns.concat(buildConfig);
  }
  if (userConfig) {
    patterns = patterns.concat(userConfig.patterns || []);
    options = userConfig.options || {};
  }
  return [patterns, options];
}

/**
 * Final webpack plugin config consists of:
 * - the default set of plugins created by this function based on whether or not
 *   a server build is being configured, whether or not the build is for an
 *   app (for which HTML will be generated), plus environment variables.
 * - extra plugins managed by this function, whose inclusion is triggered by
 *   build config, which provides default configuration for them which can be
 *   tweaked by user plugin config when appropriate.
 * - any extra plugins defined in build and user config (extra user plugins are
 *   not handled here, but by the final merge of webpack.extra config).
 */
function createPlugins(server) {
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var development = process.env.NODE_ENV === 'development';
  var production = process.env.NODE_ENV === 'production';

  var plugins = [
  // Enforce case-sensitive import paths
  new _caseSensitivePathsWebpackPlugin2.default(),
  // Replace specified expressions with values
  new _webpack2.default.DefinePlugin(_extends({
    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development')
  }, buildConfig.define, userConfig.define))];

  // Fail the build if there are compilation errors when running on CI
  if (process.env.CI || process.env.CONTINUOUS_INTEGRATION) {
    plugins.push(_webpackFailPlugin2.default);
  }

  if (server) {
    // HMR is enabled by default but can be explicitly disabled
    if (server.hot !== false) {
      plugins.push(new _webpack2.default.HotModuleReplacementPlugin(), new _webpack2.default.NoErrorsPlugin());
    }
    if (buildConfig.status) {
      plugins.push(new _WebpackStatusPlugin2.default(buildConfig.status));
    }
    // Use paths as names when serving
    plugins.push(new _webpack2.default.NamedModulesPlugin());
  }
  // If we're not serving, we're creating a static build
  else {
      // Extract CSS required as modules out into files
      var cssFilename = production ? '[name].[contenthash:8].css' : '[name].css';
      plugins.push(new _extractTextWebpackPlugin2.default(cssFilename, _extends({}, userConfig.extractText)));

      // Move modules imported from node_modules/ into a vendor chunk when enabled
      if (buildConfig.vendor) {
        plugins.push(new _webpack.optimize.CommonsChunkPlugin({
          name: 'vendor',
          minChunks: function minChunks(module, count) {
            return module.resource && module.resource.indexOf('node_modules') !== -1;
          }
        }));
      }

      // If we're generating an HTML file, we must be building a web app, so
      // configure deterministic hashing for long-term caching.
      if (buildConfig.html) {
        plugins.push(
        // Generate stable module ids instead of having Webpack assign integers.
        // HashedModuleIdsPlugin (vendored from Webpack 2) does this without
        // adding too much to bundle size and NamedModulesPlugin allows for
        // easier debugging of development builds.
        development ? new _webpack2.default.NamedModulesPlugin() : new _HashedModuleIdsPlugin2.default(),
        // The MD5 Hash plugin seems to make [chunkhash] for .js files behave
        // like [contenthash] does for extracted .css files, which is essential
        // for deterministic hashing.
        new _webpackMd5Hash2.default(),
        // The Webpack manifest is normally folded into the last chunk, changing
        // its hash - prevent this by extracting the manifest into its own
        // chunk - also essential for deterministic hashing.
        new _webpack.optimize.CommonsChunkPlugin({ name: 'manifest' }),
        // Inject the Webpack manifest into the generated HTML as a <script>
        injectManifestPlugin);
      }
    }

  if (production) {
    // Temporarily commented out to prevent an error in __webpack_require__
    // See https://github.com/webpack/webpack/issues/959#issuecomment-237438754
    // plugins.push(new optimize.DedupePlugin())
    if (userConfig.uglify !== false) {
      plugins.push(new _webpack.optimize.UglifyJsPlugin((0, _webpackMerge2.default)({
        compress: {
          screw_ie8: true,
          warnings: false
        },
        mangle: {
          screw_ie8: true
        },
        output: {
          comments: false,
          screw_ie8: true
        }
      }, userConfig.uglify)));
    }
  }

  // Generate an HTML file for web apps which pulls in generated resources
  if (buildConfig.html) {
    plugins.push(new _htmlWebpackPlugin2.default(_extends({
      chunksSortMode: 'dependency',
      template: _path2.default.join(__dirname, '../templates/webpack-template.html')
    }, buildConfig.html, userConfig.html)));
  }

  // Copy static resources
  if (buildConfig.copy) {
    plugins.push(new (Function.prototype.bind.apply(_copyWebpackPlugin2.default, [null].concat(getCopyPluginArgs(buildConfig.copy, userConfig.copy))))());
  }

  // Automatically install missing npm dependencies and add them to package.json
  // Must be enabled with an --install or --auto-install flag
  if (buildConfig.install) {
    plugins.push(new _npmInstallWebpackPlugin2.default(_extends({}, buildConfig.install, userConfig.install)));
  }

  // Insert a banner comment at the top of generated files - used for UMD builds
  if (buildConfig.banner) {
    plugins.push(new _webpack2.default.BannerPlugin(buildConfig.banner));
  }

  // Escape hatch for any extra plugins a particular build ever needs to add
  if (buildConfig.extra) {
    plugins = plugins.concat(buildConfig.extra);
  }

  return plugins;
}

/**
 * Extract top-level loader configuration provided by the user.
 */
function getTopLevelLoaderConfig(userLoaderConfig) {
  var cssPreprocessors = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (!userLoaderConfig || Object.keys(userLoaderConfig).length === 0) {
    return {};
  }

  var topLevelLoaderConfig = {};
  Object.keys(userLoaderConfig).forEach(function (loaderId) {
    var loaderConfig = userLoaderConfig[loaderId];
    if (!('config' in loaderConfig)) return;

    // Determine the proeprty to set top level loader config under
    var configPropertyName = void 0;

    // Trust the user to specify their own config key for loaders with support
    if (loaderConfig.query && 'config' in loaderConfig.query) {
      configPropertyName = loaderConfig.query.config;
    } else {
      // Otherwise, determine the correct config key
      var id = loaderId.replace(/^vendor-/, '');
      if (id in cssPreprocessors) {
        if (!cssPreprocessors[id].defaultConfig) {
          throw new Error('The ' + id + ' CSS preprocessor loader doesn\'t support a default top-level config object.');
        }
        configPropertyName = cssPreprocessors[id].defaultConfig;
      } else if (id === 'babel') {
        configPropertyName = 'babel';
      } else {
        throw new Error('The ' + id + ' loader doesn\'t appear to support a default top-level config object.');
      }
    }

    if (WEBPACK_RESERVED.indexOf(configPropertyName) !== -1) {
      throw new Error('User config for the ' + loaderId + ' loader cannot be set in ' + configPropertyName + ' - this is reserved for use by Webpack.');
    } else if (configPropertyName in topLevelLoaderConfig) {
      throw new Error('User config for the ' + loaderId + ' loader cannot be set in ' + configPropertyName + ' - this has already been used.');
    }

    topLevelLoaderConfig[configPropertyName] = loaderConfig.config;
  });

  return topLevelLoaderConfig;
}

/**
 * Create top-level PostCSS plugin config for each style pipeline.
 */
function createPostCSSConfig(userWebpackConfig) {
  var cssPreprocessors = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  // postcss-loader throws an error if a pack name is provided but isn't
  // configured, so we need to set the default PostCSS plugins for every single
  // style pipeline.
  var postcss = {
    defaults: createDefaultPostCSSPlugins(userWebpackConfig),
    vendor: createDefaultPostCSSPlugins(userWebpackConfig)
  };
  Object.keys(cssPreprocessors).forEach(function (id) {
    postcss[id] = createDefaultPostCSSPlugins(userWebpackConfig);
    postcss['vendor-' + id] = createDefaultPostCSSPlugins(userWebpackConfig);
  });
  // Any PostCSS plugins provided by the user will completely overwrite defaults
  return _extends({}, postcss, userWebpackConfig.postcss);
}

function createDefaultPostCSSPlugins(userWebpackConfig) {
  return [(0, _autoprefixer2.default)(_extends({
    browsers: ['>1%', 'last 4 versions', 'Firefox ESR', 'not ie < 9']
  }, userWebpackConfig.autoprefixer))];
}

var COMPAT_CONFIGS = exports.COMPAT_CONFIGS = {
  enzyme: {
    externals: {
      'react/addons': true,
      'react/lib/ExecutionEnvironment': true,
      'react/lib/ReactContext': true
    }
  },
  'json-schema': {
    module: {
      noParse: [/node_modules[/\\]json-schema[/\\]lib[/\\]validate\.js/]
    }
  },
  moment: function moment(_ref2) {
    var locales = _ref2.locales;

    return {
      plugins: [new _webpack2.default.ContextReplacementPlugin(/moment[/\\]locale$/, new RegExp('^\\.\\/(' + locales.join('|') + ')$'))]
    };
  },

  sinon: {
    module: {
      noParse: [/[/\\]sinon\.js/]
    },
    resolve: {
      alias: {
        sinon: 'sinon/pkg/sinon'
      }
    }
  }
};

/**
 * Create a chunk of webpack config containing compatibility tweaks for
 * libraries which are known to cause issues, to be merged into the generated
 * config.
 * Returns null if there's nothing to merge based on user config.
 */
function getCompatConfig() {
  var userCompatConfig = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var configs = [];
  Object.keys(userCompatConfig).map(function (lib) {
    if (!userCompatConfig[lib]) return;
    var compatConfig = COMPAT_CONFIGS[lib];
    if ((0, _utils.typeOf)(compatConfig) === 'function') {
      compatConfig = compatConfig(userCompatConfig[lib]);
      if (!compatConfig) return;
    }
    configs.push(compatConfig);
  });
  return configs.length > 0 ? _webpackMerge2.default.apply(undefined, configs) : null;
}

/**
 * Add default polyfills to the head of the entry array.
 */
function addPolyfillsToEntry(entry) {
  if ((0, _utils.typeOf)(entry) === 'array') {
    entry.unshift(require.resolve('../polyfills'));
  } else {
    // Assumption: there will only be one entry point, naming the entry chunk
    entry[Object.keys(entry)[0]].unshift(require.resolve('../polyfills'));
  }
}

/**
 * Create a webpack config with a curated set of default loaders suitable for
 * creating a static build (default) or serving an app with hot reloading.
 */
function createWebpackConfig(buildConfig) {
  var nwbPluginConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  (0, _debug2.default)('createWebpackConfig buildConfig: %s', (0, _utils.deepToString)(buildConfig));

  // Final webpack config is primarily driven by build configuration for the nwb
  // command being run. Each command configures a default, working webpack
  // configuration for the task it needs to perform.
  var _buildConfig$babel = buildConfig.babel;
  var buildBabelConfig = _buildConfig$babel === undefined ? {} : _buildConfig$babel;
  var entry = buildConfig.entry;
  var _buildConfig$loaders = buildConfig.loaders;
  var buildLoaderConfig = _buildConfig$loaders === undefined ? {} : _buildConfig$loaders;
  var buildOutputConfig = buildConfig.output;
  var buildPolyfill = buildConfig.polyfill;
  var _buildConfig$plugins = buildConfig.plugins;
  var buildPluginConfig = _buildConfig$plugins === undefined ? {} : _buildConfig$plugins;
  var _buildConfig$resolve = buildConfig.resolve;
  var buildResolveConfig = _buildConfig$resolve === undefined ? {} : _buildConfig$resolve;
  var _buildConfig$server = buildConfig.server;
  var server = _buildConfig$server === undefined ? false : _buildConfig$server;

  var otherBuildConfig = _objectWithoutProperties(buildConfig, ['babel', 'entry', 'loaders', 'output', 'polyfill', 'plugins', 'resolve', 'server']);

  var userWebpackConfig = userConfig.webpack || {};
  var userOutputConfig = {};
  if ('publicPath' in userWebpackConfig) {
    userOutputConfig.publicPath = userWebpackConfig.publicPath;
  }
  var userResolveConfig = {};
  if (userWebpackConfig.aliases) {
    userResolveConfig.alias = userWebpackConfig.aliases;
  }

  // Generate config for babel-loader and set it as loader config for the build
  buildLoaderConfig.babel = { query: (0, _createBabelConfig2.default)(buildBabelConfig, userConfig.babel) };

  var webpackConfig = _extends({
    module: {
      loaders: createLoaders(server, buildLoaderConfig, userWebpackConfig.loaders, nwbPluginConfig)
    },
    output: _extends({}, buildOutputConfig, userOutputConfig),
    plugins: createPlugins(server, buildPluginConfig, userWebpackConfig),
    resolve: (0, _webpackMerge2.default)({
      extensions: ['', '.js', '.json']
    }, buildResolveConfig, userResolveConfig),
    postcss: createPostCSSConfig(userWebpackConfig, nwbPluginConfig.cssPreprocessors)
  }, otherBuildConfig, getTopLevelLoaderConfig(userWebpackConfig.loaders, nwbPluginConfig.cssPreprocessors));

  if (entry) {
    // Add default polyfills to the entry chunk unless configured not to
    if (buildPolyfill !== false && userConfig.polyfill !== false) {
      addPolyfillsToEntry(entry);
    }
    webpackConfig.entry = entry;
  }

  // Create and merge compatibility configuration into the generated config if
  // specified.
  if (userWebpackConfig.compat) {
    var compatConfig = getCompatConfig(userWebpackConfig.compat);
    if (compatConfig) {
      webpackConfig = (0, _webpackMerge2.default)(webpackConfig, compatConfig);
    }
  }

  // Any extra user webpack config is merged into the generated config to give
  // them even more control.
  if (userWebpackConfig.extra) {
    webpackConfig = (0, _webpackMerge2.default)(webpackConfig, userWebpackConfig.extra);
  }

  return webpackConfig;
}